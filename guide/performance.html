<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring AI ì„±ëŠ¥ ìµœì í™” ê°€ì´ë“œ</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        .code-block { background: #2d3748; border-radius: 8px; }
        .copy-button { transition: all 0.2s ease; }
        .copy-button:hover { background-color: #4a5568; }
        .metric-card { transition: all 0.3s ease; }
        .metric-card:hover { transform: translateY(-2px); box-shadow: 0 10px 20px rgba(0,0,0,0.1); }
    </style>
</head>
<body class="bg-gray-50">
    <!-- Header -->
    <header class="bg-white shadow-sm">
        <div class="container mx-auto px-4 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center">
                    <a href="../index.html" class="flex items-center text-xl font-bold text-gray-800">
                        <i class="fab fa-spring text-green-600 mr-2"></i>
                        Spring AI Hub
                    </a>
                    <span class="mx-3 text-gray-400">/</span>
                    <span class="text-gray-600">ì„±ëŠ¥ ìµœì í™” ê°€ì´ë“œ</span>
                </div>
                <a href="../index.html" class="text-blue-600 hover:text-blue-800">
                    <i class="fas fa-home"></i> í™ˆìœ¼ë¡œ
                </a>
            </div>
        </div>
    </header>

    <div class="container mx-auto px-4 py-8">
        <div class="max-w-6xl mx-auto">
            <h1 class="text-4xl font-bold mb-4">âš¡ Spring AI ì„±ëŠ¥ ìµœì í™” ê°€ì´ë“œ</h1>
            <p class="text-gray-600 mb-8">AI ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì„±ëŠ¥ì„ ê·¹ëŒ€í™”í•˜ê³  ë¹„ìš©ì„ ìµœì í™”í•˜ëŠ” ì „ëµê³¼ ê¸°ë²•</p>

            <!-- Table of Contents -->
            <div class="bg-white rounded-lg shadow-sm p-6 mb-8">
                <h2 class="text-xl font-semibold mb-4">ëª©ì°¨</h2>
                <ul class="space-y-2 text-blue-600">
                    <li><a href="#latency-optimization" class="hover:underline">1. ì‘ë‹µ ì‹œê°„ ìµœì í™”</a></li>
                    <li><a href="#throughput" class="hover:underline">2. ì²˜ë¦¬ëŸ‰ í–¥ìƒ</a></li>
                    <li><a href="#caching" class="hover:underline">3. ìºì‹± ì „ëµ</a></li>
                    <li><a href="#token-optimization" class="hover:underline">4. í† í° ì‚¬ìš© ìµœì í™”</a></li>
                    <li><a href="#parallel-processing" class="hover:underline">5. ë³‘ë ¬ ì²˜ë¦¬</a></li>
                    <li><a href="#vector-optimization" class="hover:underline">6. ë²¡í„° ê²€ìƒ‰ ìµœì í™”</a></li>
                    <li><a href="#monitoring-performance" class="hover:underline">7. ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§</a></li>
                    <li><a href="#benchmarking" class="hover:underline">8. ë²¤ì¹˜ë§ˆí‚¹</a></li>
                </ul>
            </div>

            <!-- Section 1: Latency Optimization -->
            <section id="latency-optimization" class="mb-12">
                <h2 class="text-2xl font-semibold mb-4">1. ì‘ë‹µ ì‹œê°„ ìµœì í™”</h2>
                
                <div class="bg-white rounded-lg shadow-sm p-6 mb-6">
                    <h3 class="text-lg font-semibold mb-3">ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ</h3>
                    
                    <div class="code-block p-4 relative mb-4">
                        <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                onclick="copyCode('streaming-response')">
                            <i class="fas fa-copy"></i> ë³µì‚¬
                        </button>
                        <pre id="streaming-response"><code class="language-java">@RestController
@RequestMapping("/api/chat")
public class StreamingChatController {
    
    private final ChatClient chatClient;
    
    @PostMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> streamChat(@RequestBody ChatRequest request) {
        return chatClient.prompt()
            .user(request.getMessage())
            .stream()
            .content()
            .map(chunk -> ServerSentEvent.<String>builder()
                .id(UUID.randomUUID().toString())
                .event("message")
                .data(chunk)
                .build())
            .doOnComplete(() -> log.info("Streaming completed"))
            .doOnError(error -> log.error("Streaming error", error));
    }
    
    // ë¶€ë¶„ ì‘ë‹µ ì²˜ë¦¬
    @Service
    public class PartialResponseHandler {
        
        private final WebClient webClient;
        
        public Mono<String> processWithPartialResponse(String prompt) {
            return webClient.post()
                .uri("/chat/completions")
                .bodyValue(ChatRequest.of(prompt))
                .retrieve()
                .bodyToFlux(String.class)
                .buffer(Duration.ofMillis(100))
                .map(this::processChunks)
                .reduce(String::concat);
        }
        
        private String processChunks(List<String> chunks) {
            // ì²­í¬ ë‹¨ìœ„ë¡œ ì²˜ë¦¬í•˜ì—¬ ì‚¬ìš©ìì—ê²Œ ë¹ ë¥¸ í”¼ë“œë°± ì œê³µ
            String combined = String.join("", chunks);
            publishPartialResult(combined);
            return combined;
        }
    }
}</code></pre>
                    </div>

                    <h3 class="text-lg font-semibold mb-3 mt-6">ì—°ê²° í’€ë§</h3>
                    
                    <div class="code-block p-4 relative">
                        <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                onclick="copyCode('connection-pooling')">
                            <i class="fas fa-copy"></i> ë³µì‚¬
                        </button>
                        <pre id="connection-pooling"><code class="language-java">@Configuration
public class HttpClientConfig {
    
    @Bean
    public RestClient restClient() {
        // ì—°ê²° í’€ ì„¤ì •
        PoolingHttpClientConnectionManager connectionManager = 
            new PoolingHttpClientConnectionManager();
        connectionManager.setMaxTotal(100);
        connectionManager.setDefaultMaxPerRoute(20);
        
        // Keep-alive ì „ëµ
        ConnectionKeepAliveStrategy keepAliveStrategy = (response, context) -> {
            HeaderElementIterator it = new BasicHeaderElementIterator(
                response.headerIterator(HTTP.CONN_KEEP_ALIVE));
            
            while (it.hasNext()) {
                HeaderElement he = it.nextElement();
                String param = he.getName();
                String value = he.getValue();
                
                if (value != null && param.equalsIgnoreCase("timeout")) {
                    return Long.parseLong(value) * 1000;
                }
            }
            
            return 30 * 1000; // ê¸°ë³¸ 30ì´ˆ
        };
        
        CloseableHttpClient httpClient = HttpClients.custom()
            .setConnectionManager(connectionManager)
            .setKeepAliveStrategy(keepAliveStrategy)
            .evictIdleConnections(60, TimeUnit.SECONDS)
            .build();
        
        return RestClient.builder()
            .requestFactory(new HttpComponentsClientHttpRequestFactory(httpClient))
            .build();
    }
    
    // WebClient ì„¤ì •
    @Bean
    public WebClient webClient() {
        ConnectionProvider provider = ConnectionProvider.builder("custom")
            .maxConnections(100)
            .maxIdleTime(Duration.ofSeconds(20))
            .maxLifeTime(Duration.ofMinutes(5))
            .pendingAcquireTimeout(Duration.ofSeconds(60))
            .evictInBackground(Duration.ofSeconds(120))
            .build();
        
        HttpClient httpClient = HttpClient.create(provider)
            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)
            .doOnConnected(conn -> 
                conn.addHandlerLast(new ReadTimeoutHandler(60))
                    .addHandlerLast(new WriteTimeoutHandler(60)));
        
        return WebClient.builder()
            .clientConnector(new ReactorClientHttpConnector(httpClient))
            .build();
    }
}</code></pre>
                    </div>
                </div>
            </section>

            <!-- Section 2: Throughput -->
            <section id="throughput" class="mb-12">
                <h2 class="text-2xl font-semibold mb-4">2. ì²˜ë¦¬ëŸ‰ í–¥ìƒ</h2>
                
                <div class="bg-white rounded-lg shadow-sm p-6 mb-6">
                    <h3 class="text-lg font-semibold mb-3">ë°°ì¹˜ ì²˜ë¦¬</h3>
                    
                    <div class="code-block p-4 relative mb-4">
                        <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                onclick="copyCode('batch-processing')">
                            <i class="fas fa-copy"></i> ë³µì‚¬
                        </button>
                        <pre id="batch-processing"><code class="language-java">@Service
public class BatchProcessingService {
    
    private final ChatClient chatClient;
    private final ExecutorService executorService;
    
    public BatchProcessingService(ChatClient chatClient) {
        this.chatClient = chatClient;
        this.executorService = new ForkJoinPool(
            Runtime.getRuntime().availableProcessors()
        );
    }
    
    // ë°°ì¹˜ ì„ë² ë”© ìƒì„±
    public List<float[]> generateEmbeddingsBatch(List<String> texts) {
        // ë°°ì¹˜ í¬ê¸° ìµœì í™” (OpenAIëŠ” ìµœëŒ€ 2048ê°œ)
        int batchSize = Math.min(texts.size(), 100);
        List<List<String>> batches = Lists.partition(texts, batchSize);
        
        return batches.parallelStream()
            .map(batch -> embeddingModel.embed(batch))
            .flatMap(List::stream)
            .collect(Collectors.toList());
    }
    
    // ë°°ì¹˜ í”„ë¡¬í”„íŠ¸ ì²˜ë¦¬
    public CompletableFuture<List<ChatResponse>> processBatchAsync(
            List<ChatRequest> requests) {
        
        List<CompletableFuture<ChatResponse>> futures = requests.stream()
            .map(request -> CompletableFuture.supplyAsync(
                () -> processWithRetry(request),
                executorService
            ))
            .toList();
        
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .toList());
    }
    
    // ìŠ¤ë§ˆíŠ¸ ë°°ì¹˜ í
    @Component
    public class SmartBatchQueue {
        
        private final BlockingQueue<BatchItem> queue = new LinkedBlockingQueue<>();
        private final ScheduledExecutorService scheduler = 
            Executors.newScheduledThreadPool(2);
        
        @PostConstruct
        public void init() {
            // 100msë§ˆë‹¤ ë˜ëŠ” ë°°ì¹˜ í¬ê¸° ë„ë‹¬ì‹œ ì²˜ë¦¬
            scheduler.scheduleWithFixedDelay(
                this::processBatch, 0, 100, TimeUnit.MILLISECONDS
            );
        }
        
        public CompletableFuture<String> submit(String prompt) {
            CompletableFuture<String> future = new CompletableFuture<>();
            queue.offer(new BatchItem(prompt, future));
            return future;
        }
        
        private void processBatch() {
            List<BatchItem> batch = new ArrayList<>();
            queue.drainTo(batch, 50); // ìµœëŒ€ 50ê°œì”© ì²˜ë¦¬
            
            if (!batch.isEmpty()) {
                try {
                    List<String> prompts = batch.stream()
                        .map(BatchItem::getPrompt)
                        .toList();
                    
                    List<String> responses = batchProcess(prompts);
                    
                    for (int i = 0; i < batch.size(); i++) {
                        batch.get(i).getFuture().complete(responses.get(i));
                    }
                } catch (Exception e) {
                    batch.forEach(item -> 
                        item.getFuture().completeExceptionally(e)
                    );
                }
            }
        }
    }
}</code></pre>
                    </div>

                    <h3 class="text-lg font-semibold mb-3 mt-6">ë¹„ë™ê¸° ì²˜ë¦¬</h3>
                    
                    <div class="code-block p-4 relative">
                        <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                onclick="copyCode('async-processing')">
                            <i class="fas fa-copy"></i> ë³µì‚¬
                        </button>
                        <pre id="async-processing"><code class="language-java">@Service
public class AsyncAIService {
    
    @Async("aiTaskExecutor")
    public CompletableFuture<AnalysisResult> analyzeDocument(Document document) {
        // ë¬¸ì„œ ë¶„ì„ (ê¸´ ì‘ì—…)
        String summary = summarizeDocument(document);
        List<String> keyPoints = extractKeyPoints(document);
        Map<String, Float> sentiments = analyzeSentiment(document);
        
        return CompletableFuture.completedFuture(
            AnalysisResult.builder()
                .summary(summary)
                .keyPoints(keyPoints)
                .sentiments(sentiments)
                .build()
        );
    }
    
    // íŒŒì´í”„ë¼ì¸ ì²˜ë¦¬
    public Mono<ProcessingResult> processPipeline(String input) {
        return Mono.fromCallable(() -> preprocessInput(input))
            .subscribeOn(Schedulers.parallel())
            .flatMap(processed -> 
                Mono.zip(
                    generateEmbedding(processed),
                    classifyIntent(processed),
                    extractEntities(processed)
                )
            )
            .map(tuple -> ProcessingResult.builder()
                .embedding(tuple.getT1())
                .intent(tuple.getT2())
                .entities(tuple.getT3())
                .build())
            .timeout(Duration.ofSeconds(30))
            .retry(2);
    }
    
    @Configuration
    @EnableAsync
    public class AsyncConfig {
        
        @Bean(name = "aiTaskExecutor")
        public TaskExecutor aiTaskExecutor() {
            ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
            executor.setCorePoolSize(10);
            executor.setMaxPoolSize(50);
            executor.setQueueCapacity(100);
            executor.setThreadNamePrefix("AI-Task-");
            executor.setRejectedExecutionHandler(
                new ThreadPoolExecutor.CallerRunsPolicy()
            );
            executor.initialize();
            return executor;
        }
    }
}</code></pre>
                    </div>
                </div>
            </section>

            <!-- Section 3: Caching -->
            <section id="caching" class="mb-12">
                <h2 class="text-2xl font-semibold mb-4">3. ìºì‹± ì „ëµ</h2>
                
                <div class="bg-white rounded-lg shadow-sm p-6 mb-6">
                    <h3 class="text-lg font-semibold mb-3">í”„ë¡¬í”„íŠ¸ ìºì‹±</h3>
                    
                    <div class="code-block p-4 relative mb-4">
                        <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                onclick="copyCode('prompt-caching')">
                            <i class="fas fa-copy"></i> ë³µì‚¬
                        </button>
                        <pre id="prompt-caching"><code class="language-java">@Service
@Slf4j
public class CachedAIService {
    
    private final ChatClient chatClient;
    private final RedisTemplate<String, String> redisTemplate;
    private final LoadingCache<String, String> localCache;
    
    public CachedAIService(ChatClient chatClient, RedisTemplate<String, String> redisTemplate) {
        this.chatClient = chatClient;
        this.redisTemplate = redisTemplate;
        
        // ë¡œì»¬ ìºì‹œ (L1)
        this.localCache = Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(5, TimeUnit.MINUTES)
            .recordStats()
            .build(this::loadFromRedis);
    }
    
    public String getResponse(String prompt, CacheStrategy strategy) {
        String cacheKey = generateCacheKey(prompt);
        
        return switch (strategy) {
            case CACHE_FIRST -> getCacheFirst(cacheKey, prompt);
            case CACHE_ASIDE -> getCacheAside(cacheKey, prompt);
            case CACHE_THROUGH -> getCacheThrough(cacheKey, prompt);
        };
    }
    
    private String getCacheFirst(String key, String prompt) {
        // L1 ìºì‹œ í™•ì¸
        String cached = localCache.getIfPresent(key);
        if (cached != null) {
            log.debug("L1 cache hit: {}", key);
            return cached;
        }
        
        // L2 ìºì‹œ (Redis) í™•ì¸
        cached = redisTemplate.opsForValue().get(key);
        if (cached != null) {
            log.debug("L2 cache hit: {}", key);
            localCache.put(key, cached);
            return cached;
        }
        
        // ìºì‹œ ë¯¸ìŠ¤ - AI í˜¸ì¶œ
        String response = chatClient.prompt()
            .user(prompt)
            .call()
            .content();
        
        // ìºì‹œ ì €ì¥
        cacheResponse(key, response);
        
        return response;
    }
    
    private void cacheResponse(String key, String response) {
        // ì‘ë‹µ í’ˆì§ˆ ê²€ì¦
        if (isValidResponse(response)) {
            // L1 ìºì‹œ
            localCache.put(key, response);
            
            // L2 ìºì‹œ (TTL ì„¤ì •)
            redisTemplate.opsForValue().set(
                key, 
                response, 
                1, 
                TimeUnit.HOURS
            );
        }
    }
    
    // ì‹œë§¨í‹± ìºì‹±
    @Component
    public class SemanticCache {
        
        private final VectorStore vectorStore;
        private final EmbeddingModel embeddingModel;
        
        public Optional<String> findSimilar(String prompt, float threshold) {
            // í”„ë¡¬í”„íŠ¸ ì„ë² ë”©
            float[] promptEmbedding = embeddingModel.embed(prompt);
            
            // ìœ ì‚¬í•œ ìºì‹œëœ í”„ë¡¬í”„íŠ¸ ê²€ìƒ‰
            List<Document> similar = vectorStore.similaritySearch(
                SearchRequest.query(prompt)
                    .withTopK(1)
                    .withSimilarityThreshold(threshold)
            );
            
            if (!similar.isEmpty()) {
                Document cached = similar.get(0);
                float similarity = cached.getMetadata().get("similarity", Float.class);
                
                if (similarity > threshold) {
                    log.info("Semantic cache hit with similarity: {}", similarity);
                    return Optional.of(cached.getContent());
                }
            }
            
            return Optional.empty();
        }
        
        public void store(String prompt, String response) {
            Document doc = new Document(response);
            doc.getMetadata().put("prompt", prompt);
            doc.getMetadata().put("timestamp", Instant.now());
            doc.getMetadata().put("usage_count", 1);
            
            vectorStore.add(List.of(doc));
        }
    }
}</code></pre>
                    </div>

                    <h3 class="text-lg font-semibold mb-3 mt-6">ì„ë² ë”© ìºì‹±</h3>
                    
                    <div class="code-block p-4 relative">
                        <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                onclick="copyCode('embedding-cache')">
                            <i class="fas fa-copy"></i> ë³µì‚¬
                        </button>
                        <pre id="embedding-cache"><code class="language-java">@Service
public class EmbeddingCacheService {
    
    private final EmbeddingModel embeddingModel;
    private final Map<String, float[]> embeddingCache;
    private final BloomFilter<String> bloomFilter;
    
    public EmbeddingCacheService(EmbeddingModel embeddingModel) {
        this.embeddingModel = embeddingModel;
        this.embeddingCache = new ConcurrentHashMap<>();
        this.bloomFilter = BloomFilter.create(
            Funnels.stringFunnel(Charsets.UTF_8),
            100000,
            0.01
        );
    }
    
    public float[] getEmbedding(String text) {
        String normalized = normalizeText(text);
        
        // Bloom filterë¡œ ë¹ ë¥¸ ì¡´ì¬ í™•ì¸
        if (!bloomFilter.mightContain(normalized)) {
            return generateAndCache(normalized);
        }
        
        // ìºì‹œ í™•ì¸
        return embeddingCache.computeIfAbsent(
            normalized, 
            this::generateAndCache
        );
    }
    
    private float[] generateAndCache(String text) {
        float[] embedding = embeddingModel.embed(text);
        bloomFilter.put(text);
        
        // ìºì‹œ í¬ê¸° ì œí•œ
        if (embeddingCache.size() > 10000) {
            evictOldEntries();
        }
        
        return embedding;
    }
    
    // ë¶„ì‚° ì„ë² ë”© ìºì‹œ
    @Component
    public class DistributedEmbeddingCache {
        
        private final HazelcastInstance hazelcast;
        private final IMap<String, float[]> distributedCache;
        
        public DistributedEmbeddingCache() {
            Config config = new Config();
            config.getMapConfig("embeddings")
                .setMaxSizeConfig(new MaxSizeConfig(10000, MaxSizeConfig.MaxSizePolicy.PER_NODE))
                .setEvictionConfig(new EvictionConfig()
                    .setEvictionPolicy(EvictionPolicy.LRU)
                    .setMaxSizePolicy(MaxSizePolicy.ENTRY_COUNT));
            
            this.hazelcast = Hazelcast.newHazelcastInstance(config);
            this.distributedCache = hazelcast.getMap("embeddings");
        }
        
        public float[] get(String key) {
            return distributedCache.get(key);
        }
        
        public void put(String key, float[] embedding) {
            distributedCache.put(key, embedding, 1, TimeUnit.HOURS);
        }
    }
}</code></pre>
                    </div>
                </div>
            </section>

            <!-- Section 4: Token Optimization -->
            <section id="token-optimization" class="mb-12">
                <h2 class="text-2xl font-semibold mb-4">4. í† í° ì‚¬ìš© ìµœì í™”</h2>
                
                <div class="bg-white rounded-lg shadow-sm p-6 mb-6">
                    <h3 class="text-lg font-semibold mb-3">í”„ë¡¬í”„íŠ¸ ì••ì¶•</h3>
                    
                    <div class="code-block p-4 relative mb-4">
                        <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                onclick="copyCode('prompt-compression')">
                            <i class="fas fa-copy"></i> ë³µì‚¬
                        </button>
                        <pre id="prompt-compression"><code class="language-java">@Service
public class PromptOptimizer {
    
    private final TokenCounter tokenCounter;
    
    // í”„ë¡¬í”„íŠ¸ ì••ì¶•
    public String compressPrompt(String prompt, int maxTokens) {
        int currentTokens = tokenCounter.count(prompt);
        
        if (currentTokens <= maxTokens) {
            return prompt;
        }
        
        // ì••ì¶• ì „ëµ ì ìš©
        String compressed = prompt;
        
        // 1. ì¤‘ë³µ ì œê±°
        compressed = removeDuplicates(compressed);
        
        // 2. ë¶ˆí•„ìš”í•œ ê³µë°± ì œê±°
        compressed = removeExtraWhitespace(compressed);
        
        // 3. ì•½ì–´ ì‚¬ìš©
        compressed = applyAbbreviations(compressed);
        
        // 4. ë¬¸ì¥ ìš”ì•½ (ì—¬ì „íˆ ê¸¸ë©´)
        if (tokenCounter.count(compressed) > maxTokens) {
            compressed = summarizeSentences(compressed, maxTokens);
        }
        
        return compressed;
    }
    
    // ì»¨í…ìŠ¤íŠ¸ ìœˆë„ìš° ê´€ë¦¬
    @Component
    public class ContextWindowManager {
        
        private final int maxContextTokens = 4000;
        private final Deque<ContextEntry> contextWindow = new LinkedList<>();
        
        public String buildContext(String newMessage) {
            // ìƒˆ ë©”ì‹œì§€ í† í° ê³„ì‚°
            int newTokens = tokenCounter.count(newMessage);
            
            // ê¸°ì¡´ ì»¨í…ìŠ¤íŠ¸ ì •ë¦¬
            int currentTokens = contextWindow.stream()
                .mapToInt(ContextEntry::getTokenCount)
                .sum();
            
            // ê³µê°„ í™•ë³´
            while (currentTokens + newTokens > maxContextTokens && !contextWindow.isEmpty()) {
                ContextEntry removed = contextWindow.removeFirst();
                currentTokens -= removed.getTokenCount();
            }
            
            // ìƒˆ ë©”ì‹œì§€ ì¶”ê°€
            contextWindow.addLast(new ContextEntry(newMessage, newTokens));
            
            // ì»¨í…ìŠ¤íŠ¸ êµ¬ì„±
            return contextWindow.stream()
                .map(ContextEntry::getContent)
                .collect(Collectors.joining("\n"));
        }
        
        // ì¤‘ìš”ë„ ê¸°ë°˜ ì••ì¶•
        public String compressWithImportance(List<String> messages) {
            List<ScoredMessage> scored = messages.stream()
                .map(msg -> new ScoredMessage(msg, calculateImportance(msg)))
                .sorted((a, b) -> Double.compare(b.getScore(), a.getScore()))
                .toList();
            
            StringBuilder compressed = new StringBuilder();
            int totalTokens = 0;
            
            for (ScoredMessage msg : scored) {
                int tokens = tokenCounter.count(msg.getMessage());
                if (totalTokens + tokens <= maxContextTokens) {
                    compressed.append(msg.getMessage()).append("\n");
                    totalTokens += tokens;
                }
            }
            
            return compressed.toString();
        }
    }
    
    // ë™ì  í”„ë¡¬í”„íŠ¸ ìƒì„±
    public String generateOptimalPrompt(PromptTemplate template, Map<String, Object> variables) {
        // ê¸°ë³¸ í”„ë¡¬í”„íŠ¸ ìƒì„±
        String basePrompt = template.format(variables);
        
        // í† í° ìˆ˜ í™•ì¸
        int tokens = tokenCounter.count(basePrompt);
        
        // ëª¨ë¸ë³„ ìµœì  í† í° ìˆ˜
        int optimalTokens = getOptimalTokensForModel(template.getModel());
        
        if (tokens > optimalTokens) {
            // ê¸´ ë³€ìˆ˜ ìš”ì•½
            variables = summarizeVariables(variables, optimalTokens - template.getBaseTokens());
            basePrompt = template.format(variables);
        }
        
        return basePrompt;
    }
}</code></pre>
                    </div>

                    <div class="bg-yellow-50 p-4 rounded-lg">
                        <h4 class="font-semibold mb-2">í† í° ìµœì í™” íŒ</h4>
                        <ul class="space-y-1 text-sm">
                            <li>â€¢ ë°˜ë³µì ì¸ ì»¨í…ìŠ¤íŠ¸ ì œê±°</li>
                            <li>â€¢ ì˜ˆì‹œëŠ” ìµœì†Œí•œìœ¼ë¡œ</li>
                            <li>â€¢ ëª…í™•í•˜ê³  ê°„ê²°í•œ ì§€ì‹œë¬¸</li>
                            <li>â€¢ ê²°ê³¼ í˜•ì‹ ëª…ì‹œë¡œ ë¶ˆí•„ìš”í•œ ì„¤ëª… ë°©ì§€</li>
                            <li>â€¢ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ì¬ì‚¬ìš©</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- Section 5: Parallel Processing -->
            <section id="parallel-processing" class="mb-12">
                <h2 class="text-2xl font-semibold mb-4">5. ë³‘ë ¬ ì²˜ë¦¬</h2>
                
                <div class="bg-white rounded-lg shadow-sm p-6 mb-6">
                    <h3 class="text-lg font-semibold mb-3">ë³‘ë ¬ API í˜¸ì¶œ</h3>
                    
                    <div class="code-block p-4 relative">
                        <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                onclick="copyCode('parallel-calls')">
                            <i class="fas fa-copy"></i> ë³µì‚¬
                        </button>
                        <pre id="parallel-calls"><code class="language-java">@Service
public class ParallelAIService {
    
    private final ChatClient chatClient;
    private final ExecutorService executorService;
    
    public ParallelAIService(ChatClient chatClient) {
        this.chatClient = chatClient;
        this.executorService = new ThreadPoolExecutor(
            10, 50,
            60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(100),
            new ThreadFactoryBuilder()
                .setNameFormat("ai-parallel-%d")
                .build(),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }
    
    // ë³‘ë ¬ ë©€í‹° ëª¨ë¸ í˜¸ì¶œ
    public MultiModelResult queryMultipleModels(String prompt) {
        List<ModelConfig> models = List.of(
            new ModelConfig("gpt-4o", 0.7f),
            new ModelConfig("gpt-4o-mini", 0.5f),
            new ModelConfig("claude-3-5-sonnet", 0.6f)
        );
        
        Map<String, CompletableFuture<String>> futures = models.stream()
            .collect(Collectors.toMap(
                ModelConfig::getName,
                model -> CompletableFuture.supplyAsync(
                    () -> queryModel(prompt, model),
                    executorService
                )
            ));
        
        // ëª¨ë“  ê²°ê³¼ ìˆ˜ì§‘
        CompletableFuture<Void> allFutures = CompletableFuture.allOf(
            futures.values().toArray(new CompletableFuture[0])
        );
        
        // íƒ€ì„ì•„ì›ƒ ì„¤ì •
        try {
            allFutures.get(30, TimeUnit.SECONDS);
        } catch (TimeoutException e) {
            log.warn("Some model queries timed out");
        }
        
        Map<String, String> results = futures.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                entry -> {
                    try {
                        return entry.getValue().getNow("Error: Timeout");
                    } catch (Exception e) {
                        return "Error: " + e.getMessage();
                    }
                }
            ));
        
        return new MultiModelResult(results);
    }
    
    // ë³‘ë ¬ ë¬¸ì„œ ì²˜ë¦¬
    public List<ProcessedDocument> processDocumentsBatch(List<Document> documents) {
        // ë¬¸ì„œë¥¼ ì²­í¬ë¡œ ë¶„í• 
        int chunkSize = Math.max(1, documents.size() / Runtime.getRuntime().availableProcessors());
        List<List<Document>> chunks = Lists.partition(documents, chunkSize);
        
        // ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì²˜ë¦¬
        return chunks.parallelStream()
            .flatMap(chunk -> processChunk(chunk).stream())
            .collect(Collectors.toList());
    }
    
    // Fork/Join í”„ë ˆì„ì›Œí¬ í™œìš©
    @Component
    public class DocumentAnalysisTask extends RecursiveTask<AnalysisResult> {
        
        private static final int THRESHOLD = 10;
        private final List<Document> documents;
        
        @Override
        protected AnalysisResult compute() {
            if (documents.size() <= THRESHOLD) {
                // ì§ì ‘ ì²˜ë¦¬
                return analyzeDocuments(documents);
            }
            
            // ë¶„í•  ì •ë³µ
            int mid = documents.size() / 2;
            DocumentAnalysisTask leftTask = new DocumentAnalysisTask(
                documents.subList(0, mid)
            );
            DocumentAnalysisTask rightTask = new DocumentAnalysisTask(
                documents.subList(mid, documents.size())
            );
            
            leftTask.fork();
            AnalysisResult rightResult = rightTask.compute();
            AnalysisResult leftResult = leftTask.join();
            
            return mergeResults(leftResult, rightResult);
        }
    }
}</code></pre>
                    </div>
                </div>
            </section>

            <!-- Section 6: Vector Optimization -->
            <section id="vector-optimization" class="mb-12">
                <h2 class="text-2xl font-semibold mb-4">6. ë²¡í„° ê²€ìƒ‰ ìµœì í™”</h2>
                
                <div class="bg-white rounded-lg shadow-sm p-6 mb-6">
                    <h3 class="text-lg font-semibold mb-3">ì¸ë±ìŠ¤ ìµœì í™”</h3>
                    
                    <div class="code-block p-4 relative mb-4">
                        <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                onclick="copyCode('vector-optimization')">
                            <i class="fas fa-copy"></i> ë³µì‚¬
                        </button>
                        <pre id="vector-optimization"><code class="language-java">@Service
public class OptimizedVectorSearch {
    
    private final VectorStore vectorStore;
    private final JdbcTemplate jdbcTemplate;
    
    // HNSW ì¸ë±ìŠ¤ ìµœì í™”
    public void optimizeHNSWIndex() {
        // ì¸ë±ìŠ¤ íŒŒë¼ë¯¸í„° ì¡°ì •
        jdbcTemplate.execute("""
            ALTER INDEX vector_idx SET (
                m = 32,                -- ë” ë§ì€ ì—°ê²° (ì •í™•ë„ í–¥ìƒ)
                ef_construction = 128  -- êµ¬ì¶•ì‹œ ë” ë§ì€ íƒìƒ‰
            );
        """);
        
        // ê²€ìƒ‰ íŒŒë¼ë¯¸í„° ë™ì  ì¡°ì •
        int dataSize = getVectorCount();
        int optimalEf = calculateOptimalEf(dataSize);
        
        jdbcTemplate.execute(
            "SET hnsw.ef_search = " + optimalEf
        );
    }
    
    // ê³„ì¸µì  ê²€ìƒ‰
    public List<Document> hierarchicalSearch(String query, int topK) {
        // 1ë‹¨ê³„: ë¹ ë¥¸ ì‚¬ì „ í•„í„°ë§ (IVF)
        List<String> candidateIds = roughFilter(query, topK * 10);
        
        // 2ë‹¨ê³„: ì •ë°€ ê²€ìƒ‰ (HNSW)
        return preciseSearch(query, candidateIds, topK);
    }
    
    // í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ ìµœì í™”
    @Component
    public class HybridSearchOptimizer {
        
        private final LoadingCache<String, SearchPlan> searchPlanCache;
        
        public HybridSearchOptimizer() {
            this.searchPlanCache = Caffeine.newBuilder()
                .maximumSize(100)
                .expireAfterWrite(1, TimeUnit.HOURS)
                .build(this::createSearchPlan);
        }
        
        public List<Document> optimizedHybridSearch(
                String query, 
                SearchContext context) {
            
            // ì¿¼ë¦¬ ìœ í˜•ì— ë”°ë¥¸ ìµœì  ê³„íš ì„ íƒ
            SearchPlan plan = searchPlanCache.get(context.getQueryType());
            
            // ë³‘ë ¬ ì‹¤í–‰
            CompletableFuture<List<Document>> vectorFuture = 
                CompletableFuture.supplyAsync(() -> 
                    vectorSearch(query, plan.getVectorWeight())
                );
            
            CompletableFuture<List<Document>> keywordFuture = 
                CompletableFuture.supplyAsync(() -> 
                    keywordSearch(query, plan.getKeywordWeight())
                );
            
            // ê²°ê³¼ ë³‘í•©
            return CompletableFuture.allOf(vectorFuture, keywordFuture)
                .thenApply(v -> mergeResults(
                    vectorFuture.join(),
                    keywordFuture.join(),
                    plan
                ))
                .join();
        }
    }
    
    // ë²¡í„° ì–‘ìí™”
    public class QuantizedVectorStore {
        
        public void storeWithQuantization(String id, float[] vector) {
            // Product Quantization
            byte[] quantized = quantizeVector(vector);
            
            // ì›ë³¸ê³¼ ì–‘ìí™” ë²„ì „ ëª¨ë‘ ì €ì¥
            storeOriginal(id, vector);
            storeQuantized(id, quantized);
        }
        
        public List<String> searchWithQuantization(float[] query, int topK) {
            // 1ë‹¨ê³„: ì–‘ìí™”ëœ ë²¡í„°ë¡œ ë¹ ë¥¸ ê²€ìƒ‰
            byte[] quantizedQuery = quantizeVector(query);
            List<String> candidates = searchQuantized(quantizedQuery, topK * 5);
            
            // 2ë‹¨ê³„: ì›ë³¸ ë²¡í„°ë¡œ ì¬ìˆœìœ„í™”
            return rerankWithOriginal(query, candidates, topK);
        }
        
        private byte[] quantizeVector(float[] vector) {
            // ê°„ë‹¨í•œ ìŠ¤ì¹¼ë¼ ì–‘ìí™” ì˜ˆì‹œ
            byte[] quantized = new byte[vector.length];
            for (int i = 0; i < vector.length; i++) {
                quantized[i] = (byte) (vector[i] * 127);
            }
            return quantized;
        }
    }
}</code></pre>
                    </div>

                    <div class="bg-blue-50 p-4 rounded-lg">
                        <h4 class="font-semibold mb-2">ë²¡í„° ê²€ìƒ‰ ìµœì í™” ì „ëµ</h4>
                        <ul class="space-y-1 text-sm">
                            <li>â€¢ ì ì ˆí•œ ì¸ë±ìŠ¤ íƒ€ì… ì„ íƒ (HNSW vs IVF)</li>
                            <li>â€¢ ef_search íŒŒë¼ë¯¸í„° íŠœë‹</li>
                            <li>â€¢ ë²¡í„° ì°¨ì› ì¶•ì†Œ ê³ ë ¤</li>
                            <li>â€¢ í•„í„°ë§ ì¡°ê±´ ìµœì í™”</li>
                            <li>â€¢ ìºì‹± ì ê·¹ í™œìš©</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- Section 7: Monitoring Performance -->
            <section id="monitoring-performance" class="mb-12">
                <h2 class="text-2xl font-semibold mb-4">7. ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§</h2>
                
                <div class="bg-white rounded-lg shadow-sm p-6 mb-6">
                    <h3 class="text-lg font-semibold mb-3">ì‹¤ì‹œê°„ ì„±ëŠ¥ ì¶”ì </h3>
                    
                    <div class="code-block p-4 relative">
                        <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                onclick="copyCode('performance-monitoring')">
                            <i class="fas fa-copy"></i> ë³µì‚¬
                        </button>
                        <pre id="performance-monitoring"><code class="language-java">@Component
@Slf4j
public class PerformanceMonitor {
    
    private final MeterRegistry meterRegistry;
    private final Map<String, PerformanceStats> operationStats = new ConcurrentHashMap<>();
    
    @EventListener
    public void handlePerformanceEvent(AIOperationEvent event) {
        String operation = event.getOperationType();
        
        // ì‘ë‹µ ì‹œê°„ ê¸°ë¡
        meterRegistry.timer("ai.operation.duration",
            "operation", operation,
            "model", event.getModel()
        ).record(event.getDuration());
        
        // í† í° ì‚¬ìš©ëŸ‰
        if (event.getTokensUsed() > 0) {
            meterRegistry.counter("ai.tokens.used",
                "operation", operation,
                "model", event.getModel()
            ).increment(event.getTokensUsed());
        }
        
        // ì„±ëŠ¥ í†µê³„ ì—…ë°ì´íŠ¸
        updateStats(operation, event);
        
        // ì„±ëŠ¥ ì´ìƒ ê°ì§€
        detectPerformanceAnomaly(operation, event);
    }
    
    private void detectPerformanceAnomaly(String operation, AIOperationEvent event) {
        PerformanceStats stats = operationStats.get(operation);
        
        if (stats != null) {
            double avgDuration = stats.getAverageDuration();
            double currentDuration = event.getDuration().toMillis();
            
            // í‰ê· ì˜ 3ë°° ì´ìƒì´ë©´ ê²½ê³ 
            if (currentDuration > avgDuration * 3) {
                log.warn("Performance anomaly detected for {}: {}ms (avg: {}ms)",
                    operation, currentDuration, avgDuration);
                
                alertManager.sendAlert(PerformanceAlert.builder()
                    .operation(operation)
                    .duration(currentDuration)
                    .threshold(avgDuration * 3)
                    .build());
            }
        }
    }
    
    // ì„±ëŠ¥ ë¦¬í¬íŠ¸ ìƒì„±
    @Scheduled(cron = "0 0 * * * *") // ë§¤ì‹œê°„
    public void generatePerformanceReport() {
        PerformanceReport report = PerformanceReport.builder()
            .timestamp(Instant.now())
            .operationMetrics(collectOperationMetrics())
            .modelComparison(compareModelPerformance())
            .bottlenecks(identifyBottlenecks())
            .recommendations(generateRecommendations())
            .build();
        
        performanceReportService.save(report);
        
        if (report.hasSignificantIssues()) {
            notificationService.sendPerformanceReport(report);
        }
    }
    
    // ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ ë°ì´í„°
    @RestController
    @RequestMapping("/api/performance")
    public class PerformanceDashboardController {
        
        @GetMapping(value = "/metrics/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
        public Flux<ServerSentEvent<PerformanceMetrics>> streamMetrics() {
            return Flux.interval(Duration.ofSeconds(1))
                .map(tick -> {
                    PerformanceMetrics metrics = PerformanceMetrics.builder()
                        .avgResponseTime(getAverageResponseTime())
                        .throughput(getCurrentThroughput())
                        .errorRate(getErrorRate())
                        .activeRequests(getActiveRequests())
                        .queueSize(getQueueSize())
                        .cacheHitRate(getCacheHitRate())
                        .build();
                    
                    return ServerSentEvent.<PerformanceMetrics>builder()
                        .id(String.valueOf(tick))
                        .event("metrics")
                        .data(metrics)
                        .build();
                });
        }
    }
}</code></pre>
                    </div>
                </div>
            </section>

            <!-- Section 8: Benchmarking -->
            <section id="benchmarking" class="mb-12">
                <h2 class="text-2xl font-semibold mb-4">8. ë²¤ì¹˜ë§ˆí‚¹</h2>
                
                <div class="bg-white rounded-lg shadow-sm p-6 mb-6">
                    <h3 class="text-lg font-semibold mb-3">ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬</h3>
                    
                    <div class="code-block p-4 relative">
                        <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                onclick="copyCode('benchmarking')">
                            <i class="fas fa-copy"></i> ë³µì‚¬
                        </button>
                        <pre id="benchmarking"><code class="language-java">@Component
public class AIPerformanceBenchmark {
    
    private final List<BenchmarkScenario> scenarios = List.of(
        new SimpleChatScenario(),
        new RAGScenario(),
        new ToolCallingScenario(),
        new StreamingScenario()
    );
    
    public BenchmarkReport runCompleteBenchmark() {
        Map<String, ScenarioResult> results = new HashMap<>();
        
        for (BenchmarkScenario scenario : scenarios) {
            log.info("Running benchmark: {}", scenario.getName());
            ScenarioResult result = runScenario(scenario);
            results.put(scenario.getName(), result);
        }
        
        return BenchmarkReport.builder()
            .timestamp(Instant.now())
            .results(results)
            .summary(generateSummary(results))
            .build();
    }
    
    private ScenarioResult runScenario(BenchmarkScenario scenario) {
        // ì›Œë°ì—…
        warmup(scenario, 10);
        
        // ì‹¤ì œ ë²¤ì¹˜ë§ˆí¬
        List<Long> latencies = new ArrayList<>();
        List<Integer> tokenCounts = new ArrayList<>();
        int errors = 0;
        
        for (int i = 0; i < scenario.getIterations(); i++) {
            try {
                long start = System.nanoTime();
                BenchmarkResult result = scenario.execute();
                long duration = System.nanoTime() - start;
                
                latencies.add(duration / 1_000_000); // ms
                tokenCounts.add(result.getTokensUsed());
                
            } catch (Exception e) {
                errors++;
                log.error("Benchmark iteration failed", e);
            }
        }
        
        return ScenarioResult.builder()
            .scenarioName(scenario.getName())
            .iterations(scenario.getIterations())
            .errors(errors)
            .latencyStats(calculateStats(latencies))
            .tokenStats(calculateTokenStats(tokenCounts))
            .throughput(calculateThroughput(latencies))
            .build();
    }
    
    // JMH ë²¤ì¹˜ë§ˆí¬
    @State(Scope.Benchmark)
    public class ChatClientBenchmark {
        
        private ChatClient chatClient;
        private List<String> testPrompts;
        
        @Setup
        public void setup() {
            this.chatClient = createOptimizedChatClient();
            this.testPrompts = loadTestPrompts();
        }
        
        @Benchmark
        @BenchmarkMode(Mode.AverageTime)
        @OutputTimeUnit(TimeUnit.MILLISECONDS)
        public String benchmarkSimpleChat() {
            return chatClient.prompt()
                .user(getRandomPrompt())
                .call()
                .content();
        }
        
        @Benchmark
        @BenchmarkMode(Mode.Throughput)
        @OutputTimeUnit(TimeUnit.SECONDS)
        public List<String> benchmarkBatchProcessing() {
            return testPrompts.parallelStream()
                .map(prompt -> chatClient.prompt()
                    .user(prompt)
                    .call()
                    .content())
                .collect(Collectors.toList());
        }
    }
}</code></pre>
                    </div>
                </div>
            </section>

            <!-- Best Practices -->
            <section class="mb-12">
                <h2 class="text-2xl font-semibold mb-4">ğŸ¯ ì„±ëŠ¥ ìµœì í™” Best Practices</h2>
                
                <div class="bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg p-6">
                    <div class="grid md:grid-cols-2 gap-6">
                        <div>
                            <h3 class="font-semibold mb-3">ì‘ë‹µ ì‹œê°„ ë‹¨ì¶•</h3>
                            <ul class="space-y-1 text-sm">
                                <li>âœ… ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ í™œìš©</li>
                                <li>âœ… ì ì ˆí•œ ëª¨ë¸ ì„ íƒ</li>
                                <li>âœ… í”„ë¡¬í”„íŠ¸ ìµœì í™”</li>
                                <li>âœ… ë³‘ë ¬ ì²˜ë¦¬ êµ¬í˜„</li>
                                <li>âœ… ìºì‹± ì „ëµ ìˆ˜ë¦½</li>
                            </ul>
                        </div>
                        
                        <div>
                            <h3 class="font-semibold mb-3">ë¹„ìš© ìµœì í™”</h3>
                            <ul class="space-y-1 text-sm">
                                <li>âœ… í† í° ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§</li>
                                <li>âœ… ë°°ì¹˜ ì²˜ë¦¬ë¡œ API í˜¸ì¶œ ê°ì†Œ</li>
                                <li>âœ… ìºì‹±ìœ¼ë¡œ ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€</li>
                                <li>âœ… ëª¨ë¸ë³„ ë¹„ìš©/ì„±ëŠ¥ ë¶„ì„</li>
                                <li>âœ… í”„ë¡¬í”„íŠ¸ ì••ì¶• ê¸°ë²•</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="mt-6">
                        <h3 class="font-semibold mb-3">ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì²´í¬ë¦¬ìŠ¤íŠ¸</h3>
                        <div class="bg-white p-4 rounded-lg">
                            <ul class="space-y-1 text-sm">
                                <li>â–¡ ì‘ë‹µ ì‹œê°„ ë¶„í¬ (P50, P95, P99) ì¶”ì </li>
                                <li>â–¡ í† í° ì‚¬ìš©ëŸ‰ ë° ë¹„ìš© ëª¨ë‹ˆí„°ë§</li>
                                <li>â–¡ ìºì‹œ íˆíŠ¸ìœ¨ ì¸¡ì •</li>
                                <li>â–¡ ì—ëŸ¬ìœ¨ ë° ì¬ì‹œë„ íšŸìˆ˜ ì¶”ì </li>
                                <li>â–¡ ë™ì‹œ ìš”ì²­ ìˆ˜ ë° í í¬ê¸° ëª¨ë‹ˆí„°ë§</li>
                                <li>â–¡ ì •ê¸°ì ì¸ ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬ ì‹¤í–‰</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Next Steps -->
            <section class="bg-white rounded-lg shadow-sm p-6">
                <h2 class="text-xl font-semibold mb-4">ë‹¤ìŒ ë‹¨ê³„</h2>
                
                <div class="grid md:grid-cols-3 gap-4">
                    <a href="monitoring.html" class="block p-4 border rounded-lg hover:bg-gray-50 transition">
                        <h3 class="font-semibold text-blue-600 mb-2">ëª¨ë‹ˆí„°ë§</h3>
                        <p class="text-sm text-gray-600">ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì¶”ì  ë° ë¶„ì„</p>
                    </a>
                    
                    <a href="troubleshooting.html" class="block p-4 border rounded-lg hover:bg-gray-50 transition">
                        <h3 class="font-semibold text-green-600 mb-2">ë¬¸ì œ í•´ê²°</h3>
                        <p class="text-sm text-gray-600">ì„±ëŠ¥ ë¬¸ì œ ì§„ë‹¨ ë° í•´ê²°</p>
                    </a>
                    
                    <a href="patterns.html" class="block p-4 border rounded-lg hover:bg-gray-50 transition">
                        <h3 class="font-semibold text-purple-600 mb-2">ìµœì í™” íŒ¨í„´</h3>
                        <p class="text-sm text-gray-600">ê²€ì¦ëœ ì„±ëŠ¥ ìµœì í™” íŒ¨í„´</p>
                    </a>
                </div>
            </section>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
    
    <script>
        function copyCode(elementId) {
            const element = document.getElementById(elementId);
            const text = element.textContent;
            navigator.clipboard.writeText(text).then(() => {
                showNotification('ì½”ë“œê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
            });
        }

        function showNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'fixed top-4 right-4 bg-green-600 text-white px-4 py-2 rounded-lg z-50';
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 2000);
        }
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring AI íŒ¨í„´ ë¼ì´ë¸ŒëŸ¬ë¦¬</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        .code-block { background: #2d3748; border-radius: 8px; }
        .copy-button { transition: all 0.2s ease; }
        .copy-button:hover { background-color: #4a5568; }
        .pattern-card { transition: all 0.3s ease; }
        .pattern-card:hover { transform: translateY(-4px); box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
    </style>
</head>
<body class="bg-gray-50">
    <!-- Header -->
    <header class="bg-white shadow-sm">
        <div class="container mx-auto px-4 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center">
                    <a href="../index.html" class="flex items-center text-xl font-bold text-gray-800">
                        <i class="fab fa-spring text-green-600 mr-2"></i>
                        Spring AI Hub
                    </a>
                    <span class="mx-3 text-gray-400">/</span>
                    <span class="text-gray-600">íŒ¨í„´ ë¼ì´ë¸ŒëŸ¬ë¦¬</span>
                </div>
                <a href="../index.html" class="text-blue-600 hover:text-blue-800">
                    <i class="fas fa-home"></i> í™ˆìœ¼ë¡œ
                </a>
            </div>
        </div>
    </header>

    <div class="container mx-auto px-4 py-8">
        <div class="max-w-6xl mx-auto">
            <h1 class="text-4xl font-bold mb-4">ğŸ¯ Spring AI íŒ¨í„´ ë¼ì´ë¸ŒëŸ¬ë¦¬</h1>
            <p class="text-gray-600 mb-8">ê²€ì¦ëœ AI ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ê³„ íŒ¨í„´ê³¼ êµ¬í˜„ ì˜ˆì œ</p>

            <!-- Pattern Categories -->
            <div class="flex flex-wrap gap-4 mb-8">
                <button class="pattern-filter bg-blue-600 text-white px-4 py-2 rounded-lg" data-category="all">
                    ì „ì²´ íŒ¨í„´
                </button>
                <button class="pattern-filter bg-gray-200 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-300" data-category="conversation">
                    ëŒ€í™” íŒ¨í„´
                </button>
                <button class="pattern-filter bg-gray-200 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-300" data-category="retrieval">
                    ê²€ìƒ‰ íŒ¨í„´
                </button>
                <button class="pattern-filter bg-gray-200 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-300" data-category="workflow">
                    ì›Œí¬í”Œë¡œìš° íŒ¨í„´
                </button>
                <button class="pattern-filter bg-gray-200 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-300" data-category="integration">
                    í†µí•© íŒ¨í„´
                </button>
            </div>

            <!-- Pattern: Chain of Thought -->
            <div class="pattern-card bg-white rounded-lg shadow-lg overflow-hidden mb-8" data-category="conversation">
                <div class="bg-gradient-to-r from-blue-500 to-blue-600 text-white p-6">
                    <h2 class="text-2xl font-bold flex items-center">
                        <i class="fas fa-link mr-3"></i>
                        Chain of Thought (ì‚¬ê³ ì˜ ì—°ì‡„)
                    </h2>
                    <p class="mt-2 text-blue-100">ë³µì¡í•œ ë¬¸ì œë¥¼ ë‹¨ê³„ë³„ë¡œ ì¶”ë¡ í•˜ì—¬ í•´ê²°í•˜ëŠ” íŒ¨í„´</p>
                </div>
                
                <div class="p-6">
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">íŒ¨í„´ ì„¤ëª…</h3>
                        <p class="text-gray-600 mb-4">
                            Chain of ThoughtëŠ” AIê°€ ë¬¸ì œë¥¼ í•´ê²°í•  ë•Œ ì¤‘ê°„ ì¶”ë¡  ë‹¨ê³„ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ìƒì„±í•˜ë„ë¡ í•˜ëŠ” íŒ¨í„´ì…ë‹ˆë‹¤.
                            ì´ë¥¼ í†µí•´ ë” ì •í™•í•˜ê³  ì„¤ëª… ê°€ëŠ¥í•œ ë‹µë³€ì„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                        </p>
                        
                        <div class="bg-gray-100 p-4 rounded-lg mb-4">
                            <h4 class="font-semibold mb-2">ì ìš© ì‹œë‚˜ë¦¬ì˜¤:</h4>
                            <ul class="space-y-1 text-sm">
                                <li>â€¢ ìˆ˜í•™ ë¬¸ì œ í•´ê²°</li>
                                <li>â€¢ ë³µì¡í•œ ë…¼ë¦¬ ì¶”ë¡ </li>
                                <li>â€¢ ë‹¤ë‹¨ê³„ ì˜ì‚¬ê²°ì •</li>
                                <li>â€¢ ë¬¸ì œ ë¶„ì„ ë° ë””ë²„ê¹…</li>
                            </ul>
                        </div>
                    </div>

                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">êµ¬í˜„ ì½”ë“œ</h3>
                        <div class="code-block p-4 relative">
                            <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                    onclick="copyCode('cot-pattern')">
                                <i class="fas fa-copy"></i> ë³µì‚¬
                            </button>
                            <pre id="cot-pattern"><code class="language-java">@Service
public class ChainOfThoughtService {
    
    private final ChatClient chatClient;
    
    public ChainOfThoughtService(ChatClient.Builder builder) {
        this.chatClient = builder
            .defaultOptions(OpenAiChatOptions.builder()
                .withModel("gpt-4o")
                .withTemperature(0.3f) // ë‚®ì€ ì˜¨ë„ë¡œ ì¼ê´€ì„± í–¥ìƒ
                .build())
            .build();
    }
    
    public ThoughtChainResult solveWithReasoning(String problem) {
        String cotPrompt = """
            ë¬¸ì œë¥¼ ë‹¨ê³„ë³„ë¡œ ë¶„ì„í•˜ê³  í•´ê²°í•˜ì„¸ìš”.
            
            ë¬¸ì œ: {problem}
            
            ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ë‹µë³€í•˜ì„¸ìš”:
            
            **1ë‹¨ê³„: ë¬¸ì œ ì´í•´**
            [ë¬¸ì œì˜ í•µì‹¬ ìš”ì†Œì™€ ìš”êµ¬ì‚¬í•­ ë¶„ì„]
            
            **2ë‹¨ê³„: ì ‘ê·¼ ë°©ë²•**
            [í•´ê²°ì„ ìœ„í•œ ì „ëµ ìˆ˜ë¦½]
            
            **3ë‹¨ê³„: ë‹¨ê³„ë³„ í•´ê²°**
            [êµ¬ì²´ì ì¸ í•´ê²° ê³¼ì •]
            
            **4ë‹¨ê³„: ê²€ì¦**
            [ë‹µë³€ì˜ íƒ€ë‹¹ì„± í™•ì¸]
            
            **ìµœì¢… ë‹µë³€**
            [ê²°ë¡ ]
            """;
        
        String response = chatClient.prompt()
            .user(u -> u.text(cotPrompt).param("problem", problem))
            .call()
            .content();
        
        return parseThoughtChain(response);
    }
    
    // ìê°€ ì¼ê´€ì„± ê²€ì¦
    public ConsistentResult solveWithSelfConsistency(String problem, int samples) {
        List<ThoughtChainResult> results = IntStream.range(0, samples)
            .parallel()
            .mapToObj(i -> solveWithReasoning(problem))
            .toList();
        
        // ê°€ì¥ ì¼ê´€ëœ ë‹µë³€ ì„ íƒ
        Map<String, Long> answerFrequency = results.stream()
            .collect(Collectors.groupingBy(
                ThoughtChainResult::getFinalAnswer,
                Collectors.counting()
            ));
        
        String mostConsistentAnswer = answerFrequency.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse("");
        
        double consistency = (double) answerFrequency.get(mostConsistentAnswer) / samples;
        
        return ConsistentResult.builder()
            .answer(mostConsistentAnswer)
            .consistency(consistency)
            .allResults(results)
            .build();
    }
}</code></pre>
                        </div>
                    </div>

                    <div class="bg-blue-50 p-4 rounded-lg">
                        <h4 class="font-semibold mb-2">ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ:</h4>
                        <div class="text-sm space-y-2">
                            <p><strong>ì…ë ¥:</strong> "í•œ ìƒì ì—ì„œ ì‚¬ê³¼ 5ê°œì— 1000ì›, ì˜¤ë Œì§€ 3ê°œì— 1500ì›ì…ë‹ˆë‹¤. ì‚¬ê³¼ 20ê°œì™€ ì˜¤ë Œì§€ 15ê°œë¥¼ ì‚¬ë ¤ë©´ ì–¼ë§ˆê°€ í•„ìš”í•œê°€ìš”?"</p>
                            <p><strong>AI ì¶”ë¡  ê³¼ì •:</strong></p>
                            <ul class="ml-4 space-y-1">
                                <li>1ë‹¨ê³„: ì‚¬ê³¼ ë‹¨ê°€ = 1000ì› Ã· 5ê°œ = 200ì›</li>
                                <li>2ë‹¨ê³„: ì˜¤ë Œì§€ ë‹¨ê°€ = 1500ì› Ã· 3ê°œ = 500ì›</li>
                                <li>3ë‹¨ê³„: ì‚¬ê³¼ 20ê°œ = 200ì› Ã— 20 = 4000ì›</li>
                                <li>4ë‹¨ê³„: ì˜¤ë Œì§€ 15ê°œ = 500ì› Ã— 15 = 7500ì›</li>
                                <li>ìµœì¢…: ì´ ë¹„ìš© = 4000ì› + 7500ì› = 11,500ì›</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pattern: RAG with Reranking -->
            <div class="pattern-card bg-white rounded-lg shadow-lg overflow-hidden mb-8" data-category="retrieval">
                <div class="bg-gradient-to-r from-green-500 to-green-600 text-white p-6">
                    <h2 class="text-2xl font-bold flex items-center">
                        <i class="fas fa-sort-amount-down mr-3"></i>
                        RAG with Reranking (ì¬ìˆœìœ„í™” RAG)
                    </h2>
                    <p class="mt-2 text-green-100">ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì¬ìˆœìœ„í™”í•˜ì—¬ ì •í™•ë„ë¥¼ í–¥ìƒì‹œí‚¤ëŠ” íŒ¨í„´</p>
                </div>
                
                <div class="p-6">
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">íŒ¨í„´ ì„¤ëª…</h3>
                        <p class="text-gray-600 mb-4">
                            ê¸°ë³¸ ë²¡í„° ê²€ìƒ‰ í›„ Cross-Encoderë‚˜ ì¶”ê°€ ëª¨ë¸ì„ ì‚¬ìš©í•˜ì—¬ ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì¬ìˆœìœ„í™”í•¨ìœ¼ë¡œì¨
                            ë” ê´€ë ¨ì„± ë†’ì€ ë¬¸ì„œë¥¼ ìƒìœ„ì— ë°°ì¹˜í•©ë‹ˆë‹¤.
                        </p>
                    </div>

                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">êµ¬í˜„ ì½”ë“œ</h3>
                        <div class="code-block p-4 relative">
                            <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                    onclick="copyCode('reranking-pattern')">
                                <i class="fas fa-copy"></i> ë³µì‚¬
                            </button>
                            <pre id="reranking-pattern"><code class="language-java">@Service
public class RerankingRAGService {
    
    private final VectorStore vectorStore;
    private final ChatClient chatClient;
    private final CrossEncoder crossEncoder;
    
    public RerankingRAGService(VectorStore vectorStore, 
                               ChatClient.Builder builder,
                               CrossEncoder crossEncoder) {
        this.vectorStore = vectorStore;
        this.chatClient = builder.build();
        this.crossEncoder = crossEncoder;
    }
    
    public RerankingResult searchWithReranking(String query, int initialK, int finalK) {
        // 1ë‹¨ê³„: ì´ˆê¸° ë²¡í„° ê²€ìƒ‰ (ë„‰ë„‰í•˜ê²Œ)
        List<Document> candidates = vectorStore.similaritySearch(
            SearchRequest.query(query).withTopK(initialK)
        );
        
        // 2ë‹¨ê³„: Cross-Encoderë¡œ ì¬ìˆœìœ„í™”
        List<RankedDocument> rerankedDocs = candidates.parallelStream()
            .map(doc -> {
                double relevanceScore = crossEncoder.score(query, doc.getContent());
                return new RankedDocument(doc, relevanceScore);
            })
            .sorted((a, b) -> Double.compare(b.getScore(), a.getScore()))
            .limit(finalK)
            .toList();
        
        // 3ë‹¨ê³„: ë‹¤ì–‘ì„± ë³´ì¥ (MMR - Maximal Marginal Relevance)
        List<Document> diverseResults = applyMMR(rerankedDocs, 0.7);
        
        // 4ë‹¨ê³„: ì»¨í…ìŠ¤íŠ¸ êµ¬ì„± ë° ë‹µë³€ ìƒì„±
        String context = buildContextWithMetadata(diverseResults);
        
        String answer = chatClient.prompt()
            .system("ì£¼ì–´ì§„ ë¬¸ì„œë¥¼ ë°”íƒ•ìœ¼ë¡œ ì •í™•í•˜ê²Œ ë‹µë³€í•˜ì„¸ìš”.")
            .user(u -> u.text("ì§ˆë¬¸: {query}\n\nì»¨í…ìŠ¤íŠ¸:\n{context}")
                .param("query", query)
                .param("context", context))
            .call()
            .content();
        
        return RerankingResult.builder()
            .answer(answer)
            .sources(diverseResults)
            .rerankingScores(extractScores(rerankedDocs))
            .build();
    }
    
    // MMR (Maximal Marginal Relevance) êµ¬í˜„
    private List<Document> applyMMR(List<RankedDocument> documents, double lambda) {
        if (documents.isEmpty()) return List.of();
        
        List<Document> selected = new ArrayList<>();
        Set<Integer> selectedIndices = new HashSet<>();
        
        // ì²« ë²ˆì§¸ ë¬¸ì„œëŠ” ê°€ì¥ ê´€ë ¨ì„± ë†’ì€ ê²ƒ ì„ íƒ
        selected.add(documents.get(0).getDocument());
        selectedIndices.add(0);
        
        while (selected.size() < Math.min(5, documents.size())) {
            double maxMMR = -1;
            int bestIdx = -1;
            
            for (int i = 0; i < documents.size(); i++) {
                if (selectedIndices.contains(i)) continue;
                
                RankedDocument candidate = documents.get(i);
                double relevance = candidate.getScore();
                
                // ê¸°ì¡´ ì„ íƒëœ ë¬¸ì„œë“¤ê³¼ì˜ ìµœëŒ€ ìœ ì‚¬ë„ ê³„ì‚°
                double maxSimilarity = selected.stream()
                    .mapToDouble(sel -> cosineSimilarity(
                        candidate.getDocument().getContent(),
                        sel.getContent()
                    ))
                    .max()
                    .orElse(0);
                
                // MMR ì ìˆ˜ ê³„ì‚°
                double mmr = lambda * relevance - (1 - lambda) * maxSimilarity;
                
                if (mmr > maxMMR) {
                    maxMMR = mmr;
                    bestIdx = i;
                }
            }
            
            if (bestIdx != -1) {
                selected.add(documents.get(bestIdx).getDocument());
                selectedIndices.add(bestIdx);
            } else {
                break;
            }
        }
        
        return selected;
    }
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pattern: Multi-Agent Orchestration -->
            <div class="pattern-card bg-white rounded-lg shadow-lg overflow-hidden mb-8" data-category="workflow">
                <div class="bg-gradient-to-r from-purple-500 to-purple-600 text-white p-6">
                    <h2 class="text-2xl font-bold flex items-center">
                        <i class="fas fa-project-diagram mr-3"></i>
                        Multi-Agent Orchestration (ë©€í‹° ì—ì´ì „íŠ¸ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜)
                    </h2>
                    <p class="mt-2 text-purple-100">ì—¬ëŸ¬ ì „ë¬¸ ì—ì´ì „íŠ¸ë¥¼ ì¡°ìœ¨í•˜ì—¬ ë³µì¡í•œ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” íŒ¨í„´</p>
                </div>
                
                <div class="p-6">
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">íŒ¨í„´ ì„¤ëª…</h3>
                        <p class="text-gray-600 mb-4">
                            ê°ê° íŠ¹ì • ì—­í• ì„ ë‹´ë‹¹í•˜ëŠ” ì—¬ëŸ¬ AI ì—ì´ì „íŠ¸ë¥¼ ì¡°ìœ¨í•˜ì—¬ ë³µì¡í•œ ì‘ì—…ì„ íš¨ìœ¨ì ìœ¼ë¡œ ìˆ˜í–‰í•©ë‹ˆë‹¤.
                            ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°ê°€ ì‘ì—…ì„ ë¶„ì„í•˜ê³  ì ì ˆí•œ ì—ì´ì „íŠ¸ì—ê²Œ í• ë‹¹í•©ë‹ˆë‹¤.
                        </p>
                    </div>

                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">êµ¬í˜„ ì½”ë“œ</h3>
                        <div class="code-block p-4 relative">
                            <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                    onclick="copyCode('orchestration-pattern')">
                                <i class="fas fa-copy"></i> ë³µì‚¬
                            </button>
                            <pre id="orchestration-pattern"><code class="language-java">@Service
@Slf4j
public class AgentOrchestrator {
    
    private final Map<String, SpecializedAgent> agents = new HashMap<>();
    private final ChatClient orchestratorClient;
    private final TaskQueue taskQueue;
    
    public AgentOrchestrator(ChatClient.Builder builder) {
        this.orchestratorClient = builder.build();
        this.taskQueue = new PriorityBlockingQueue<>();
        
        // ì „ë¬¸ ì—ì´ì „íŠ¸ ë“±ë¡
        registerAgent("researcher", new ResearchAgent());
        registerAgent("analyzer", new AnalysisAgent());
        registerAgent("writer", new WritingAgent());
        registerAgent("reviewer", new ReviewAgent());
        registerAgent("coder", new CodingAgent());
    }
    
    public OrchestrationResult executeComplexTask(ComplexTask task) {
        log.info("Starting orchestration for task: {}", task.getName());
        
        // 1. ì‘ì—… ë¶„ì„ ë° ê³„íš
        ExecutionPlan plan = analyzeAndPlan(task);
        
        // 2. ì„œë¸ŒíƒœìŠ¤í¬ ìƒì„±
        List<SubTask> subTasks = decomposeTasks(task, plan);
        
        // 3. ë³‘ë ¬/ìˆœì°¨ ì‹¤í–‰
        Map<String, TaskResult> results = new ConcurrentHashMap<>();
        
        // ì˜ì¡´ì„± ê·¸ë˜í”„ ê¸°ë°˜ ì‹¤í–‰
        DAG<SubTask> dependencyGraph = buildDependencyGraph(subTasks);
        
        dependencyGraph.topologicalSort().forEach(level -> {
            // ê°™ì€ ë ˆë²¨ì˜ íƒœìŠ¤í¬ëŠ” ë³‘ë ¬ ì‹¤í–‰
            List<CompletableFuture<TaskResult>> futures = level.stream()
                .map(subTask -> CompletableFuture.supplyAsync(() -> 
                    executeSubTask(subTask, results)
                ))
                .toList();
            
            // ë ˆë²¨ ì™„ë£Œ ëŒ€ê¸°
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
            
            futures.forEach(future -> {
                TaskResult result = future.join();
                results.put(result.getTaskId(), result);
            });
        });
        
        // 4. ê²°ê³¼ ì¢…í•©
        return synthesizeResults(task, results);
    }
    
    private TaskResult executeSubTask(SubTask subTask, Map<String, TaskResult> previousResults) {
        String agentType = selectAgent(subTask);
        SpecializedAgent agent = agents.get(agentType);
        
        if (agent == null) {
            throw new AgentNotFoundException("No agent found for type: " + agentType);
        }
        
        // ì´ì „ ê²°ê³¼ë¥¼ ì»¨í…ìŠ¤íŠ¸ë¡œ ì „ë‹¬
        Context context = buildContext(subTask, previousResults);
        
        try {
            AgentResponse response = agent.execute(subTask, context);
            
            return TaskResult.success(
                subTask.getId(),
                response.getResult(),
                response.getMetadata()
            );
        } catch (Exception e) {
            log.error("SubTask execution failed: {}", subTask.getId(), e);
            
            // ì¬ì‹œë„ ë˜ëŠ” ëŒ€ì²´ ì „ëµ
            return handleFailure(subTask, e);
        }
    }
    
    // ë™ì  ì—ì´ì „íŠ¸ ì„ íƒ
    private String selectAgent(SubTask task) {
        String selectionPrompt = """
            ë‹¤ìŒ ì‘ì—…ì— ê°€ì¥ ì í•©í•œ ì—ì´ì „íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”.
            
            ì‘ì—…: {task}
            
            ì‚¬ìš© ê°€ëŠ¥í•œ ì—ì´ì „íŠ¸:
            - researcher: ì •ë³´ ìˆ˜ì§‘ ë° ì¡°ì‚¬
            - analyzer: ë°ì´í„° ë¶„ì„ ë° ì¸ì‚¬ì´íŠ¸ ë„ì¶œ
            - writer: ì½˜í…ì¸  ì‘ì„± ë° ë¬¸ì„œí™”
            - reviewer: í’ˆì§ˆ ê²€í†  ë° ê°œì„ 
            - coder: ì½”ë“œ ìƒì„± ë° ê¸°ìˆ  êµ¬í˜„
            
            ì„ íƒ: [ì—ì´ì „íŠ¸ ì´ë¦„ë§Œ ë°˜í™˜]
            """;
        
        return orchestratorClient.prompt()
            .user(u -> u.text(selectionPrompt).param("task", task.getDescription()))
            .call()
            .content()
            .trim()
            .toLowerCase();
    }
    
    // ì ì‘í˜• ì¬ê³„íš
    @Component
    public class AdaptiveReplanner {
        
        public void monitorAndAdapt(OrchestrationContext context) {
            context.getExecutingTasks().forEach(task -> {
                if (task.isDelayed() || task.hasFailed()) {
                    ExecutionPlan newPlan = replan(context, task);
                    context.updatePlan(newPlan);
                }
            });
        }
        
        private ExecutionPlan replan(OrchestrationContext context, SubTask failedTask) {
            // AIë¥¼ ì‚¬ìš©í•œ ë™ì  ì¬ê³„íš
            String replanPrompt = """
                í˜„ì¬ ì‘ì—…ì´ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ëŒ€ì•ˆì„ ì œì‹œí•˜ì„¸ìš”.
                
                ì‹¤íŒ¨í•œ ì‘ì—…: {task}
                ì‹¤íŒ¨ ì›ì¸: {reason}
                í˜„ì¬ ì§„í–‰ ìƒí™©: {progress}
                
                ê°€ëŠ¥í•œ ëŒ€ì•ˆ:
                1. ë‹¤ë¥¸ ì—ì´ì „íŠ¸ ì‚¬ìš©
                2. ì‘ì—… ë¶„í• 
                3. ì ‘ê·¼ ë°©ë²• ë³€ê²½
                4. ì‘ì—… ê±´ë„ˆë›°ê¸°
                """;
            
            return parseExecutionPlan(orchestratorClient.prompt()
                .user(u -> u.text(replanPrompt)
                    .param("task", failedTask)
                    .param("reason", failedTask.getFailureReason())
                    .param("progress", context.getProgress()))
                .call()
                .content());
        }
    }
}</code></pre>
                        </div>
                    </div>

                    <div class="bg-purple-50 p-4 rounded-lg">
                        <h4 class="font-semibold mb-2">ì‚¬ìš© ì˜ˆì‹œ:</h4>
                        <p class="text-sm">
                            "íšŒì‚¬ì˜ ì—°ê°„ ë³´ê³ ì„œë¥¼ ì‘ì„±í•˜ë¼"ëŠ” ë³µì¡í•œ ì‘ì—…ì„ ë°›ìœ¼ë©´:
                        </p>
                        <ul class="text-sm mt-2 space-y-1">
                            <li>1. <strong>Research Agent</strong>: ì¬ë¬´ ë°ì´í„°, ì‹œì¥ ë™í–¥ ìˆ˜ì§‘</li>
                            <li>2. <strong>Analysis Agent</strong>: ë°ì´í„° ë¶„ì„ ë° ì¸ì‚¬ì´íŠ¸ ë„ì¶œ</li>
                            <li>3. <strong>Writing Agent</strong>: ë³´ê³ ì„œ ì´ˆì•ˆ ì‘ì„±</li>
                            <li>4. <strong>Review Agent</strong>: í’ˆì§ˆ ê²€í†  ë° ê°œì„ </li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Pattern: Streaming with Backpressure -->
            <div class="pattern-card bg-white rounded-lg shadow-lg overflow-hidden mb-8" data-category="integration">
                <div class="bg-gradient-to-r from-orange-500 to-orange-600 text-white p-6">
                    <h2 class="text-2xl font-bold flex items-center">
                        <i class="fas fa-stream mr-3"></i>
                        Streaming with Backpressure (ë°±í”„ë ˆì…” ìŠ¤íŠ¸ë¦¬ë°)
                    </h2>
                    <p class="mt-2 text-orange-100">ëŒ€ìš©ëŸ‰ ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¼ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” íŒ¨í„´</p>
                </div>
                
                <div class="p-6">
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">íŒ¨í„´ ì„¤ëª…</h3>
                        <p class="text-gray-600 mb-4">
                            í´ë¼ì´ì–¸íŠ¸ì˜ ì²˜ë¦¬ ì†ë„ì— ë§ì¶° ìŠ¤íŠ¸ë¦¼ ì†ë„ë¥¼ ì¡°ì ˆí•˜ì—¬ ë©”ëª¨ë¦¬ ì˜¤ë²„í”Œë¡œìš°ë¥¼ ë°©ì§€í•˜ê³ 
                            ì•ˆì •ì ì¸ ì‹¤ì‹œê°„ ì²˜ë¦¬ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤.
                        </p>
                    </div>

                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">êµ¬í˜„ ì½”ë“œ</h3>
                        <div class="code-block p-4 relative">
                            <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                    onclick="copyCode('streaming-pattern')">
                                <i class="fas fa-copy"></i> ë³µì‚¬
                            </button>
                            <pre id="streaming-pattern"><code class="language-java">@RestController
@RequestMapping("/api/stream")
public class StreamingController {
    
    private final ChatClient chatClient;
    private final ReactiveCircuitBreaker circuitBreaker;
    
    @PostMapping(value = "/chat", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<StreamChunk>> streamWithBackpressure(
            @RequestBody ChatRequest request) {
        
        return chatClient.prompt()
            .user(request.getMessage())
            .stream()
            .chatResponse()
            .transform(this::applyBackpressure)
            .transform(this::enrichWithMetadata)
            .map(this::toServerSentEvent)
            .doOnError(this::handleStreamError)
            .onErrorResume(this::fallbackStream);
    }
    
    private Flux<ChatResponse> applyBackpressure(Flux<ChatResponse> upstream) {
        return upstream
            // ë²„í¼ í¬ê¸° ì œí•œ
            .onBackpressureBuffer(100, 
                dropped -> log.warn("Dropped message due to backpressure"),
                BufferOverflowStrategy.DROP_OLDEST)
            
            // ì²˜ë¦¬ ì†ë„ ì œí•œ
            .sample(Duration.ofMillis(50))
            
            // íƒ€ì„ì•„ì›ƒ ì„¤ì •
            .timeout(Duration.ofMinutes(5))
            
            // ë™ì‹œì„± ì œì–´
            .publishOn(Schedulers.parallel(), 10);
    }
    
    private Flux<EnrichedResponse> enrichWithMetadata(Flux<ChatResponse> responses) {
        AtomicInteger tokenCount = new AtomicInteger();
        AtomicLong startTime = new AtomicLong(System.currentTimeMillis());
        
        return responses.map(response -> {
            int tokens = countTokens(response.getResult().getOutput().getContent());
            tokenCount.addAndGet(tokens);
            
            return EnrichedResponse.builder()
                .content(response.getResult().getOutput().getContent())
                .tokenCount(tokens)
                .totalTokens(tokenCount.get())
                .timestamp(System.currentTimeMillis())
                .latency(System.currentTimeMillis() - startTime.get())
                .build();
        });
    }
    
    // ì ì‘í˜• ìŠ¤íŠ¸ë¦¬ë°
    @Component
    public class AdaptiveStreamingService {
        
        private final Map<String, StreamMetrics> clientMetrics = new ConcurrentHashMap<>();
        
        public Flux<String> adaptiveStream(String sessionId, String prompt) {
            StreamMetrics metrics = clientMetrics.computeIfAbsent(
                sessionId, 
                k -> new StreamMetrics()
            );
            
            return chatClient.prompt()
                .user(prompt)
                .stream()
                .content()
                .transformDeferred(stream -> {
                    // í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬ ì†ë„ ì¸¡ì •
                    double processingRate = metrics.getProcessingRate();
                    
                    if (processingRate < 10) { // ëŠë¦° í´ë¼ì´ì–¸íŠ¸
                        return stream
                            .delayElements(Duration.ofMillis(100))
                            .onBackpressureLatest();
                    } else if (processingRate < 50) { // ì¤‘ê°„ ì†ë„
                        return stream
                            .onBackpressureBuffer(50);
                    } else { // ë¹ ë¥¸ í´ë¼ì´ì–¸íŠ¸
                        return stream;
                    }
                })
                .doOnNext(chunk -> metrics.recordChunk(chunk.length()))
                .doOnComplete(() -> metrics.complete())
                .doOnError(error -> metrics.error(error));
        }
    }
    
    // ì²­í¬ ì§‘ê³„ ë° ë°°ì¹˜ ì²˜ë¦¬
    public Flux<BatchedChunk> streamWithBatching(String prompt) {
        return chatClient.prompt()
            .user(prompt)
            .stream()
            .content()
            .buffer(Duration.ofMillis(200), 10) // 200ms ë˜ëŠ” 10ê°œì”© ë°°ì¹˜
            .map(chunks -> BatchedChunk.builder()
                .content(String.join("", chunks))
                .chunkCount(chunks.size())
                .timestamp(System.currentTimeMillis())
                .build())
            .filter(batch -> !batch.getContent().isEmpty());
    }
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pattern: Contextual Memory -->
            <div class="pattern-card bg-white rounded-lg shadow-lg overflow-hidden mb-8" data-category="conversation">
                <div class="bg-gradient-to-r from-indigo-500 to-indigo-600 text-white p-6">
                    <h2 class="text-2xl font-bold flex items-center">
                        <i class="fas fa-brain mr-3"></i>
                        Contextual Memory (ë§¥ë½ì  ë©”ëª¨ë¦¬)
                    </h2>
                    <p class="mt-2 text-indigo-100">ëŒ€í™” ë§¥ë½ê³¼ ì‚¬ìš©ì ì •ë³´ë¥¼ ì§€ëŠ¥ì ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” íŒ¨í„´</p>
                </div>
                
                <div class="p-6">
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">íŒ¨í„´ ì„¤ëª…</h3>
                        <p class="text-gray-600 mb-4">
                            ë‹¨ìˆœí•œ ëŒ€í™” íˆìŠ¤í† ë¦¬ë¥¼ ë„˜ì–´ ì¤‘ìš”í•œ ì •ë³´ë¥¼ ì¶”ì¶œí•˜ê³  ì••ì¶•í•˜ì—¬ ì¥ê¸°ì ìœ¼ë¡œ ìœ ì§€í•˜ë©°,
                            í•„ìš”í•  ë•Œ ì ì ˆí•œ ë§¥ë½ì„ ê²€ìƒ‰í•˜ì—¬ ì œê³µí•©ë‹ˆë‹¤.
                        </p>
                    </div>

                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">êµ¬í˜„ ì½”ë“œ</h3>
                        <div class="code-block p-4 relative">
                            <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                    onclick="copyCode('memory-pattern')">
                                <i class="fas fa-copy"></i> ë³µì‚¬
                            </button>
                            <pre id="memory-pattern"><code class="language-java">@Service
public class ContextualMemoryService {
    
    private final VectorStore memoryStore;
    private final ChatClient chatClient;
    private final Cache<String, ConversationContext> activeContexts;
    
    public ContextualMemoryService(VectorStore memoryStore, 
                                  ChatClient.Builder builder) {
        this.memoryStore = memoryStore;
        this.chatClient = builder.build();
        this.activeContexts = Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterAccess(30, TimeUnit.MINUTES)
            .build();
    }
    
    public MemoryAwareResponse chat(String userId, String message) {
        // 1. í™œì„± ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ
        ConversationContext context = activeContexts.get(userId, 
            k -> loadOrCreateContext(userId));
        
        // 2. ê´€ë ¨ ì¥ê¸° ë©”ëª¨ë¦¬ ê²€ìƒ‰
        List<Memory> relevantMemories = searchRelevantMemories(userId, message);
        
        // 3. ì¤‘ìš”ë„ í‰ê°€
        ImportanceScore importance = evaluateImportance(message, context);
        
        // 4. ì‘ë‹µ ìƒì„±
        String response = generateContextualResponse(
            message, 
            context, 
            relevantMemories
        );
        
        // 5. ì»¨í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        updateContext(context, message, response, importance);
        
        // 6. ì¤‘ìš”í•œ ì •ë³´ëŠ” ì¥ê¸° ë©”ëª¨ë¦¬ë¡œ
        if (importance.isSignificant()) {
            storeToLongTermMemory(userId, message, response, importance);
        }
        
        return MemoryAwareResponse.builder()
            .response(response)
            .memoriesUsed(relevantMemories.size())
            .contextWindow(context.getWindowSize())
            .build();
    }
    
    // ì§€ëŠ¥ì  ë©”ëª¨ë¦¬ ì••ì¶•
    private void compressMemories(String userId) {
        List<Memory> allMemories = loadAllMemories(userId);
        
        if (allMemories.size() < 100) return;
        
        String compressionPrompt = """
            ë‹¤ìŒ ëŒ€í™” ê¸°ë¡ì„ í•µì‹¬ ì •ë³´ë§Œ ë‚¨ê¸°ê³  ì••ì¶•í•˜ì„¸ìš”:
            
            {memories}
            
            ì••ì¶• ê·œì¹™:
            1. ì¤‘ìš”í•œ ì‚¬ì‹¤ê³¼ ì„ í˜¸ë„ ìœ ì§€
            2. ë°˜ë³µë˜ëŠ” ì •ë³´ëŠ” í•˜ë‚˜ë¡œ í†µí•©
            3. ì‹œê°„ì  ë§¥ë½ ë³´ì¡´
            4. ê°œì¸ì •ë³´ì™€ ì¤‘ìš” ê²°ì •ì‚¬í•­ ìš°ì„ 
            """;
        
        String compressed = chatClient.prompt()
            .user(u -> u.text(compressionPrompt)
                .param("memories", formatMemories(allMemories)))
            .call()
            .content();
        
        // ì••ì¶•ëœ ë©”ëª¨ë¦¬ ì €ì¥
        Memory compressedMemory = Memory.builder()
            .userId(userId)
            .content(compressed)
            .type(MemoryType.COMPRESSED)
            .timestamp(Instant.now())
            .sourceCount(allMemories.size())
            .build();
        
        storeMemory(compressedMemory);
        
        // ì›ë³¸ ë©”ëª¨ë¦¬ ì•„ì¹´ì´ë¸Œ
        archiveMemories(allMemories);
    }
    
    // ë™ì  ì»¨í…ìŠ¤íŠ¸ ìœˆë„ìš°
    @Component
    public class DynamicContextWindow {
        
        public List<Message> selectRelevantHistory(
                ConversationContext context,
                String currentMessage,
                int maxTokens) {
            
            List<Message> allMessages = context.getMessages();
            
            // ìµœê·¼ ë©”ì‹œì§€ëŠ” í•­ìƒ í¬í•¨
            List<Message> selected = new ArrayList<>();
            int tokenCount = 0;
            
            // ìµœê·¼ 3ê°œ ë©”ì‹œì§€
            for (int i = allMessages.size() - 1; i >= 0 && i > allMessages.size() - 4; i--) {
                Message msg = allMessages.get(i);
                tokenCount += countTokens(msg.getContent());
                selected.add(0, msg);
            }
            
            // ë‚¨ì€ í† í°ìœ¼ë¡œ ê´€ë ¨ì„± ë†’ì€ ê³¼ê±° ë©”ì‹œì§€ ì„ íƒ
            List<Message> candidates = allMessages.subList(
                0, 
                Math.max(0, allMessages.size() - 3)
            );
            
            List<ScoredMessage> scoredMessages = candidates.stream()
                .map(msg -> new ScoredMessage(
                    msg,
                    calculateRelevance(msg, currentMessage)
                ))
                .sorted((a, b) -> Double.compare(b.getScore(), a.getScore()))
                .toList();
            
            for (ScoredMessage scored : scoredMessages) {
                int msgTokens = countTokens(scored.getMessage().getContent());
                if (tokenCount + msgTokens > maxTokens) break;
                
                selected.add(0, scored.getMessage());
                tokenCount += msgTokens;
            }
            
            return selected;
        }
    }
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pattern: Hierarchical Task Decomposition -->
            <div class="pattern-card bg-white rounded-lg shadow-lg overflow-hidden mb-8" data-category="workflow">
                <div class="bg-gradient-to-r from-red-500 to-red-600 text-white p-6">
                    <h2 class="text-2xl font-bold flex items-center">
                        <i class="fas fa-sitemap mr-3"></i>
                        Hierarchical Task Decomposition (ê³„ì¸µì  ì‘ì—… ë¶„í•´)
                    </h2>
                    <p class="mt-2 text-red-100">ë³µì¡í•œ ì‘ì—…ì„ ê³„ì¸µì ìœ¼ë¡œ ë¶„í•´í•˜ì—¬ ê´€ë¦¬í•˜ëŠ” íŒ¨í„´</p>
                </div>
                
                <div class="p-6">
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">êµ¬í˜„ ì½”ë“œ</h3>
                        <div class="code-block p-4 relative">
                            <button class="copy-button absolute top-2 right-2 bg-gray-600 text-white px-2 py-1 rounded text-xs" 
                                    onclick="copyCode('decomposition-pattern')">
                                <i class="fas fa-copy"></i> ë³µì‚¬
                            </button>
                            <pre id="decomposition-pattern"><code class="language-java">@Service
public class HierarchicalTaskDecomposer {
    
    private final ChatClient chatClient;
    private final TaskExecutor taskExecutor;
    
    public TaskTree decomposeTask(String mainGoal, int maxDepth) {
        TaskNode root = TaskNode.builder()
            .id(UUID.randomUUID().toString())
            .description(mainGoal)
            .level(0)
            .status(TaskStatus.PENDING)
            .build();
        
        decomposeRecursively(root, maxDepth);
        
        return new TaskTree(root);
    }
    
    private void decomposeRecursively(TaskNode parent, int remainingDepth) {
        if (remainingDepth <= 0 || isAtomic(parent)) {
            return;
        }
        
        List<TaskNode> subtasks = generateSubtasks(parent);
        parent.setChildren(subtasks);
        
        subtasks.parallelStream().forEach(child -> 
            decomposeRecursively(child, remainingDepth - 1)
        );
    }
    
    private List<TaskNode> generateSubtasks(TaskNode parent) {
        String decompositionPrompt = """
            ì‘ì—…ì„ í•˜ìœ„ ì‘ì—…ìœ¼ë¡œ ë¶„í•´í•˜ì„¸ìš”.
            
            ì‘ì—…: {task}
            
            ê·œì¹™:
            1. ê° í•˜ìœ„ ì‘ì—…ì€ ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰ ê°€ëŠ¥í•´ì•¼ í•¨
            2. 3-5ê°œì˜ í•˜ìœ„ ì‘ì—…ìœ¼ë¡œ ë¶„í•´
            3. MECE ì›ì¹™ ì ìš© (ìƒí˜¸ ë°°íƒ€ì , ì „ì²´ í¬ê´„ì )
            
            í˜•ì‹:
            1. [ì‘ì—…ëª…]: [ì„¤ëª…]
            2. [ì‘ì—…ëª…]: [ì„¤ëª…]
            ...
            """;
        
        String response = chatClient.prompt()
            .user(u -> u.text(decompositionPrompt)
                .param("task", parent.getDescription()))
            .call()
            .content();
        
        return parseSubtasks(response, parent);
    }
    
    // ì‘ì—… ì‹¤í–‰ ìŠ¤ì¼€ì¤„ëŸ¬
    public ExecutionResult executeTaskTree(TaskTree tree) {
        ExecutionContext context = new ExecutionContext();
        PriorityQueue<TaskNode> readyQueue = new PriorityQueue<>(
            Comparator.comparingInt(TaskNode::getPriority)
        );
        
        // ë¦¬í”„ ë…¸ë“œë¶€í„° ì‹œì‘
        tree.getLeafNodes().forEach(readyQueue::offer);
        
        while (!readyQueue.isEmpty()) {
            TaskNode task = readyQueue.poll();
            
            // ë³‘ë ¬ ì‹¤í–‰ ê°€ëŠ¥í•œ ì‘ì—…ë“¤ ìˆ˜ì§‘
            List<TaskNode> batch = collectParallelTasks(readyQueue, task);
            batch.add(task);
            
            // ë³‘ë ¬ ì‹¤í–‰
            List<CompletableFuture<TaskResult>> futures = batch.stream()
                .map(t -> CompletableFuture.supplyAsync(() -> 
                    executeTask(t, context)
                ))
                .toList();
            
            // ê²°ê³¼ ìˆ˜ì§‘
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .join();
            
            // ì™„ë£Œëœ ì‘ì—…ì˜ ë¶€ëª¨ í™•ì¸
            batch.forEach(t -> {
                TaskNode parent = t.getParent();
                if (parent != null && parent.allChildrenComplete()) {
                    readyQueue.offer(parent);
                }
            });
        }
        
        return context.getResult();
    }
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Best Practices Section -->
            <section class="mt-12">
                <h2 class="text-2xl font-semibold mb-6">ğŸ¯ íŒ¨í„´ ì„ íƒ ê°€ì´ë“œ</h2>
                
                <div class="bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg p-6">
                    <div class="grid md:grid-cols-2 gap-6">
                        <div>
                            <h3 class="font-semibold mb-3">ëŒ€í™”í˜• ì• í”Œë¦¬ì¼€ì´ì…˜</h3>
                            <ul class="space-y-2 text-sm">
                                <li>â€¢ <strong>Contextual Memory</strong>: ì¥ê¸° ëŒ€í™” ê´€ë¦¬</li>
                                <li>â€¢ <strong>Chain of Thought</strong>: ë³µì¡í•œ ì¶”ë¡ </li>
                                <li>â€¢ <strong>Streaming with Backpressure</strong>: ì‹¤ì‹œê°„ ì‘ë‹µ</li>
                            </ul>
                        </div>
                        
                        <div>
                            <h3 class="font-semibold mb-3">ë¬¸ì„œ ì²˜ë¦¬ ì‹œìŠ¤í…œ</h3>
                            <ul class="space-y-2 text-sm">
                                <li>â€¢ <strong>RAG with Reranking</strong>: ì •í™•í•œ ê²€ìƒ‰</li>
                                <li>â€¢ <strong>Hierarchical Decomposition</strong>: ëŒ€ëŸ‰ ì²˜ë¦¬</li>
                                <li>â€¢ <strong>Multi-Agent Orchestration</strong>: ë³µí•© ë¶„ì„</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="mt-6">
                        <h3 class="font-semibold mb-3">íŒ¨í„´ ì¡°í•© ì˜ˆì‹œ</h3>
                        <div class="bg-white p-4 rounded-lg">
                            <p class="text-sm mb-2"><strong>ê³ ê¸‰ ê³ ê° ì§€ì› ì‹œìŠ¤í…œ:</strong></p>
                            <ul class="text-sm space-y-1 ml-4">
                                <li>1. Contextual Memoryë¡œ ê³ ê° íˆìŠ¤í† ë¦¬ ê´€ë¦¬</li>
                                <li>2. RAG with Rerankingìœ¼ë¡œ ê´€ë ¨ ë¬¸ì„œ ê²€ìƒ‰</li>
                                <li>3. Chain of Thoughtë¡œ ë¬¸ì œ í•´ê²°</li>
                                <li>4. Streaming with Backpressureë¡œ ì‹¤ì‹œê°„ ì‘ë‹µ</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
    
    <script>
        function copyCode(elementId) {
            const element = document.getElementById(elementId);
            const text = element.textContent;
            navigator.clipboard.writeText(text).then(() => {
                showNotification('ì½”ë“œê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
            });
        }

        function showNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'fixed top-4 right-4 bg-green-600 text-white px-4 py-2 rounded-lg z-50';
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 2000);
        }

        // Pattern filtering
        document.querySelectorAll('.pattern-filter').forEach(button => {
            button.addEventListener('click', function() {
                // Update active button
                document.querySelectorAll('.pattern-filter').forEach(b => {
                    b.classList.remove('bg-blue-600', 'text-white');
                    b.classList.add('bg-gray-200', 'text-gray-700');
                });
                this.classList.remove('bg-gray-200', 'text-gray-700');
                this.classList.add('bg-blue-600', 'text-white');

                // Filter patterns
                const category = this.dataset.category;
                document.querySelectorAll('.pattern-card').forEach(card => {
                    if (category === 'all' || card.dataset.category === category) {
                        card.style.display = 'block';
                    } else {
                        card.style.display = 'none';
                    }
                });
            });
        });
    </script>
</body>
</html>